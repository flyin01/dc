---
title: "Intro_to_package_building"
output: html_notebook
---
  
### Chapters  
  
1. The R Package Structure  
2. Documenting Packages  
3. Checking and Building R-packages  
4. Adding Unit Tests to R-packages  
  
### 1. The R Package Structure  
    
In this chapter, we will learn the basics of creating an R package. We will learn about the structure of R packages, set up a package, and write a function and include it in your package. We will also learn about the metadata stored in the DESCRIPTION and NAMESPACE files.  
  
**The structure of an R package**  
  
An R package can include:  
  
* Functions  
* Data  
* Documentation  
* Vignettes  
* Tests  
  
You don´t need all this.  
  
**Mandatory components**  
  
As a minimum our packages must include:  
  
* R directory - where you put the R code  
* man directory - where you store your documentation  
* NAMESPACE file - contains info about functions that the package imports from other packages and functions that the package makes available to its users  
* DESCRIPTION file - contains metadata about the package, author, purpose, current version, dependencies    
  
**Pacckages for easy creation of packages!**  
  
We dont need to do all this for hand, we will use packages that are designed for package building.  
  
* `devtools` , helps us stick to the right package structure  
* `roxygen2` , makes it simple to create docs in man directory and manage NAMESPACE file  
  
What we need to do our self is to write the functions we want and update the information in the template description file.  
  
**Setting up an R package**  
  
We will use the `devtools` package alot to maintain the structure of the package but also to write tests. The aim of `devtools` is to make development as easy as possible for package developers. Core devtools functions:  
  
* `create()`  
* `document()`  
* `check()`  
* `build()`  
* `test()`  
  
**create()**  
  
The `create()` function will create the basic structure, generating a NAMESPACE file, DESCRIPTION FILE and the R directory. It does not create the man directory yet, that happens later. To use `create()` you need to tell where to create the package and what name it should have. In below example we will create a packages called `simutils` in a new folder in the current work directory. The name of the folder we provide becomes the name of the package.

```{r}
# set work directory for where to create the new package, run in console!
```

Note: Avoid names already taken on **`CRAN`**    
```{r}
# Do not run
library(devtools)
create("simutils")
```
Running above `create("simutils")` will launch a new RStudio instance and create a new folder in the work directory:  
  
`/simutils` , a new folder  
  
In this folder **the following objects are** created:  
  
* /R , folder  
* .gitignore  
* .Rbuildignore  
* DESCRIPTION  
* NAMESPACE  
* simutils.Rproj  
  
Practice!  
  
**The structure of an R package**  
  
You can use `devtools` to create the basic structure of an R package by using the `create()` function.

There are some optional arguments to this function but the main one that you will use is the path argument. You use this to specify where your package will be created and the name that your package will take.

If you want to create the package in your current working directory, as you often will, you just need to supply the name for the package. When naming your package remember to think about:
  
* If the name is already taken by another package.  
* Whether the name makes it clear what the package does.  
  
Instructions:  
* Use the `create()` function to create a new R package called `datasummary`.  
* Use the `dir()` function to see what files and directories are created in your package.  
```{r}
# DO NOT RUN IF THE FOLDER datasummary ALREADY EXISTS!
library(devtools)

# Use the create function to set up your first package
create("datasummary")

# Take a look at the files and folders in your package
dir("datasummary")
```
Now let's take a look at the contents of your package in more detail
  
**Contents of an R package**  
  
When you create an R package there are a number of files and folders that it can contain. This can include folders to store data, user guides (known as vignettes), tests (more on these later in the course) and demos among others. As a minimum there are only two directories that must be included along with two additional files -- the `DESCRIPTION` and the `NAMESPACE`.

Of the two compulsory directories one contains all of the user guides for your functions. As you will see later in the course this is created in a special way for you. The other is included by the `create()` function. Which of the following is the second compulsory directory?  
  
Possible Answers:  
A. data  
B. tests  
C. inst  
D. R  
Correct: D  
That's right - all the code for your package goes in the R directory!  
    
**Writing a simple function**  
  
Whilst there are packages that contain only data, typically packages are created to collect together functions for performing a specific task.  
  
For our package you are going to keep the functions simple. You are going to create a package that produces custom summary output for your data.  
  
Instructions:  
* Write a function, `numeric_summary()`, that takes two arguments, a vector `x` and the logical `na.rm`.  
* Include a check to your function so it fails with an error message if the vector `x` is not numeric.  
* The function should return a `data.frame` containing the minimum, median, standard deviation and maximum values.  
* Check that your function works using the `Ozone` column of the `airquality` data and removing missing values.  
  
```{r}
# Create numeric_summary() function
numeric_summary <- function(x, na.rm = TRUE) {

    # Include an error if x is not numeric
    if(!is.numeric(x)){
        stop("Data must be numeric")
    }
    
    # Create data frame
    data.frame( min = min(x, na.rm = na.rm),
                median = median(x, na.rm = na.rm),
                sd = sd(x, na.rm = na.rm),
                max = max(x, na.rm = na.rm))
}

# Test numeric_summary() function
numeric_summary(airquality$Ozone, na.rm = TRUE)
```
Now let's look at how you include your function in a package.  
  
**Including functions in a package**  
  
Once you have written your function code you need to save it in the `R` directory of your package. Typically you can do that by saving an R script in the usual manner (i.e. "Save As").

In the instance that you already have objects created, as you did in the last exercise, that you want to write to the R directory you can do this programmatically. You can use the function `dump()` to send a named R function to a particular file. The two arguments that you need to pass to this function are the name of the R object, as a character string, and the path to the file that you want to create, including the extension `.R`.  
  
Instructions:  
* Use the `dir()` function again to see what is currently available in the `R` directory of `datasummary`.  
* Using the `dump()` function, write the `numeric_summary()` function to the R directory, saving the file as `numeric_summary.R`.  
* Print the contents of the `R` directory again.  
```{r}
# What is in the R directory before adding a function?
dir("datasummary/R")

# Use the dump() function to write the numeric_summary function
dump("numeric_summary", file = "datasummary/R/numeric_summary.R")

# Verify that the file is in the correct directory
dir("datasummary/R")
```
The function has now been saved correctly!  
  
**DESCRIPTION and NAMESPACE files**  
  
DESCRIPTION file  

* General package information  
* Author and maintainer details  
* Package dependencies  
* License  
  
Example in folder datasummary/DESCRIPTION and another one below.
```{r}
Package: datasummary
Title: What the Package Does (One Line, Title Case)
Version: 0.0.0.9000
Authors@R: C( 
    person("John", "Doe", 
           email = "first.last@domain.com", role = c("aut", "cre")),
    person("Tom", "Hill",
           email = "first.last@domain.com", role = c("aut", "ctn")))
Description: Solves some analytical problems blazing fast.
Depends:
    R (>= 3.4.2)
License: GPL-2
Encoding: UTF-8
LazyData: true
Roxygen: list(markdown = TRUE)
RoxygenNote: 7.1.0
Imports: dplyr, 
    purrr
Suggests: testhat,
    knitr,
    rmarkdown
VignetteBuilder: knitr
```
  
**NAMESPACE file**  
  
The NAMESPACE file controls two important things:  
  
* Functions or packages imported for use by our package to be able to run  
* Functions exported by our package for people to use  
  
We do NOT edit this file by hand!  
We will manage it with all our other documentation.  
  
Example NAMESPACE file in folder datasummary/DESCRIPTION and another one below.
```{r}
# Generated by roxygen2: do not edit by hand

export(na_counter)
export(sample_from_data)
import(dplyr)
import(purrr)
```
We are exporting na_counter to our users and we need dplyr, purrr so it works.
  
A package should not have the same name as an existing package and its name must only contain letters, numbers, or dots.  
  
The DESCRIPTION file contains details about the other packages your package uses, it doesn't include which functions are in your package.  
  
From the role = c('cph','ctb','cre','aut') the maintainer is the role 'cre'.  
  
**Optional directories**  
  
We have seen what the mandatory directories are that we need but we can also include many other things like:  
  
* Data  
* Vignettes  
* Tests  
* Compiled code  
* Translations  
  
**Data**  
  
Most of this can be included with the `use_data()` function. Example with Data.
```{r}
# DO NOT RUN
sim_data <- data.frame(
  ID = 1:10,
  Value = sample(1:11, 10),
  Apples = sample(c(TRUE,FALSE), 10, replace = TRUE)
)
```
Data is stored in the R directory as and R data file. We can call the `use_data()` function to add the data from an R object. The function needs to know the name of the R object and the location of the package.
```{r}
# DO NOT RUN
use_data(sim_data, pkg = "simutiles")
```
  
**Vignette**  
  
If we want to create a vignette, which is like a user-guid we can call the `use_vignette` function.
```{r}
use_vignette("my_first_vignette", pkg = "simutils")
```
This will create a directory called vignette and create a template vignette for us to edit with the name we provide. `devtools` will create an `rmarkdown` template in which `devtools` will create a special header which we should leave as is so that R identifies our vignette.  
  
**Best practice for structuring code**  
  
You cannot create just any structure or your package wont build!  
  
Guidelines for the R directory:  
* No subdirectories  
* Don't have everything in one script  
 * For small packages you might want to have one file for each function, where each file name reflects the function.  
* Don't have a large number of small files.  
* As package gets larger, group similar functions together into one file.  
* A good practice is to have large functions on their own while have similar, smaller functions grouped together.  
  
Practise!  
  
**The use_* functions**  
  
Beyond the required structure you can include a number of additional directories containing elements such as vignettes (user guides), data and unit tests. The `devtools` package makes it really simple for you to add to the package structure by providing a series of `use_*` functions. For example, `use_data()` and `use_vignette()`. Note that when adding vignettes, it's best not to include any spaces in the vignette name.

When you are adding data you need to provide the name of the data object along with the argument `pkg`, giving the path to the package that you want to put your data in.  
  
Instrucitons:  
* Using the `dir()` function, check what directories are currently in the package?  
* The `weather` dataset has been created for you. Add it to your package.  
* Add a vignette titled `"Generating_Summaries_with_Data_Summary"`.
```{r}
# OMA. Create weather data
weather = data.frame(Day = as.integer(c(1,2,3,4,5,6,7)),
                     Temp = as.integer(c(22,19,18,24,15,21,14)),
                     Weather = as.character(c("Snow","Snow","Sun","Rain",
                                              "Rain","Snow","Rain")))
library(devtools)
#In console set run: setwd("C:/repo/dc/datasummary")

#What is in the package at the moment?
dir("datasummary")

# Add the weather data
use_data(weather, pkg = "datasummary", overwrite = TRUE)

# What directories do you now have in your package now?
dir("datasummary")

```
This error is due to this project should be in a root folder, not as sub-folder to dc.  
  
**Best practice for structuring code**  
  
A typical R package contains a number of functions that you need to maintain. Whilst there are no strict rules around how you should structure code in a package you generally want to avoid having all of your code in a single script. As you can't have sub-directories you also need to think carefully about how you name the file so that you can find your code again in the future.

Suppose you were to write another function for your package that takes all numeric columns in your data and returns a data frame of all of their summary statistics. What would be the best way to structure this code?  
  
Instructions:  
* Send the new `data_summary()` function to a new file taking the same name as the function (You should use the dump() function here)
```{r}
data_summary <- function(x, na.rm = TRUE){
  
  num_data <- dplyr::select_if(x, .predicate = is.numeric)
  
  purrr::map_df(num_data, .f = numeric_summary, na.rm = TRUE, .id = "ID")
  # numeric_summary function was defined and dumped previously to our package
  
}

# Test function
data_summary(weather)

# Write the function to the R directory
dump("data_summary", file = "datasummary/R/data_summary.R")
```
Now that you've learned about the R package structure, the next step is to see how to document your package.

End of chapter 1.  
  
  
### 2. Documenting Packages  
  
**Introduction to roxygen2**  
  
The documentation of a package is very important for the user of the packages.  
  
* Help files  
  
Function help files list all of the arguments to the function and detail the purpose and use of each and other information. To create these files we can use a package called `roxygen2`. It allows us to ad a header to a function containing all the important information about the function. When you then run an appropriate build function the documentation in the form of help files is built automatically from these roxygen headers. Let´s look at one example:  
  
**roxygen headers**  
  
```{r}
#' Sample from data
#'
#' Sample rows form a dataset.
#'
#' This function has been designed to sample from the rows of a two dimensional
#' data set, returning all columns of sampled rows. Sampiing is done with 
#' replacement by default
#'
#' @param data A data frame or matrix from which rows are to be sampled
#' @param size Numeric. Number of rows to return
#' @param replace Logical. Sample with replacement? TRUE by default.
#'
#' @authoer Firstname Lastname
#'
#' @import dplyr
#'
#' @returns A data set of the same type as input with \code{size} rows.
#' @export  
#'
#' @examples
#' sample_from_data(airquality, size=10)
sample_from_data <- function(data, size, replace=TRUE) {
  
  if(!is.numeric(size)){
    stop("size must be numeric value")
  }
  
  if(is.matrix(data)){
    data = as.data.frame(data)
  }
}
```
Each row in the roxygen header start with a hash and a single quote `#'`.  
Following this you can indicate particular components of the helpfile.  
Let´s look at some components in details.   
  
* The first paragraph of the header is treated as title of the help file `#' Sample from data`, this should be short and no longer than one sentence.  
* The second paragraph of the header is treated as a description for the help page `#' Sample rows form a dataset.` and should include a brief description of the function  
* The third paragraph `#' This function has been designed..`, is treated as the detailed section. We might want to provide more info about complex parameters of functionality here.  
* For everything else, we need to use special tags preceeded by the `@` symbol.  
* The `@param` tags define each of the function arguments and the corresponding help text that the user will see in the help documentation. It is usefull to specify the object type and give a short description: `@param size Numeric. Number of rows to return`  
* Using other functions in packages requires us to import the package, not just loading it using the `library()` function. The `@import` tag is used to specify which package must be imported, e.g: `@import dplyr`. When you import a funciton you make it´s NAMESPACE and functions available to your package. In this example the `dplyr` function is imported so that the functions of the latter package can be use in the body of our package.  
  
Practise!  
  
**A simple funciton header**  
  
The `roxygen` headers are included in the same script as the function code. You use roxygen comments `#'` to identify a line as part of the roxygen header. You can include regular R comments in the header if you wish, using the usual comment character, `#`.

The first three lines of the header have special meaning and you don't need to use tags to identify them. The first three lines are:  
  
* title  
* description  
* details  
  
Since you don't mention any tags to identify the first three lines, it is necessary that you seperate each one of them by a new line. For example:
```{r}
#' Title goes here
#'
#' Description goes here
#'
#' Details go here
```
Instructions:  
  
* Add the title "Numeric Summaries" to your header.  
* Add the following short description of the function: "Summarises numeric data and returns a data frame containing the minimum value, median, standard deviation, and maximum value."  
```{r}
# Add a title and description
#' Numeric Summaries
#'
#' Summarises numeric data and returns a data frame containing the minimum value, median, standard deviation, and maximum value
numeric_summary <- function(x, na.rm){

    if(!is.numeric(x)){
        stop("Data must be numeric")
    }
    
    data.frame( min = min(x, na.rm = na.rm),
                median = median(x, na.rm = na.rm),
                sd = sd(x, na.rm = na.rm),
                max = max(x, na.rm = na.rm))
}
```
Now let's look at how to document function arguments.  
  
**Documenting function arguments**  
  
JATKA TÄSTÄ  
https://campus.datacamp.com/courses/developing-r-packages/documenting-packages?ex=3
